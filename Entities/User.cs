using System.Text.Json.Serialization;

namespace WebApi.Entities
{
    public class User
    {
        public int Id { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public string Username { get; set; }

        [JsonIgnore]
        public string Password { get; set; }

        // the value saved here is the jwt token generated by this .NET Core api - not the token sent with the request
        //  *Note: this "Token" is not really relevant to the user, especially for our use case - so the way this example app uses this token value is not really technically relevant or correct, but we can modify the approach to be useful to ourselves by changing this to store the token sent with the request
        //      i.e. the Authentication Api (A-API) will have a token generated per user (a unique token for each user)
        //           - the authentication api will then call other apis (ff api, view model api) using hard-coded secrets 
        //              for the authentication piece
        //           - to use the user data stored in the jwt token created for each user in the Authentication API (A-API),
        //              the A-API will need to expose the token to the controller for the called API
        //
        //  API Heirarchy
        //      Entry Point Application (User Interface, e.g. FF UI)
        //          - user enters "login" credentials, UI application then sends credentials to Authentication API (A-API) to determine success or failed authentication
        //          - Authentication API (A-API) should return success message for validated/authenticated user, and failure message for invalid user (to be diffentiated from api authentication failure - also possibly obfuscated in existing design)
        //          - Entry Point Application/UI should then go on to treat user as authenticated and move on to subsequent functionality
        //              - should username be required for further endpoints beyond authentication, the username can be treated as a text string
        //              - the username can also be stored/encoded in a jwt token which is passed to subsequent APIs in a body (ff-api, view-model-api)
        //                   - this jwt token which encodes the user data is not be confused with the jwt token/secret which should be used by the calling api to gain access to the called underlying apis
        //                     (i.e. as previously understood, a hard-coded secret/token would be used by apis to call underlying apis - these would not store user data, only be used to grant access to the api to call the underlying api)
        //
        //      Authentication API (A-API)
        //          - generates unique jwt token per user, stores user data in jwt json data
        //          - for the Authentication API (A-API) to complete/verify user is valid (authenticated), the A-API 
        //              will need to call various entities to validate users (depending on the application to which the user needs access)
        //          e.g. If the Authentication API needs to verify a user exists in View, the Authentication API would need to send
        //              a text string username and encoded password to the View Model API (or directly make a call to the view database, depending on what approach was chosen, if any was determined)
        //              once user is determined to be valid and authenticated, the Authentication API then returns a success validation message (or however this model was designed - I suspect this part of the design may have been obfuscated and possibly become recursive/redundant)
        //
        //      Entry Point Application/UI underlying API (e.g. FF API)
        //          - this api holds controllers for the UI application to access application specific data
        //
        //      Data Model API (e.g. View Model API)
        //          - this api holds data model specific controllers (e.g. get scheduled visits, get available timeslots)
        public string Token { get; set; }

        // instead of changing how this example app uses "Token", I have added an additional field named RequestToken which is meant
        //  to store the token sent with the request that is expected to be storing user data
        //  a better name for this might be "UserToken"
        public string RequestToken { get; set; }
    }
}